# Логические формулы I. Вычислить значение

Зададим формулы логики высказываний с помощью следующего рекурсивного типа:

```hs
data LogExpr = FConst               -- False
             | TConst               -- True
             | Var String           -- Переменная, например Var X
             | Not LogExpr          -- Отрицание
             | And LogExpr LogExpr  -- Конъюнкция
             | Or LogExpr LogExpr   -- Дизъюнкция
```

Считаем, что имя переменной удовлетворяет стандартным договоренностям, т.е. состоит из строчных и заглавных символов латиницы, подчеркиваний и цифр и начинается не с цифры.

Например, такая формула, представленная типом `LogExpr`,

```hs
(And (Var "x") (Or (Not (Var "y")) (Var "z")))
```

имеет такое строковое представление:

```hs
(x & (^y | z))
```

Здесь
- `^` означает отрицание, `&` — конъюнкцию, `|` — дизъюнкцию
- операции `&` и `|` отделены от своих операндов ровно одним пробелом и заключены в скобки (даже там, где их можно было бы и опустить)
- отрицание не отделяется пробелами от операнда и имеет приоритет более высокий, чем конъюнкция и дизъюнкция, поэтому ее не нужно заключать в скобки.

Реализуйте функцию `compute :: [(String,Bool)] -> LogExpr -> Bool`, которая вычисляет значение логического выражения при заданных значениях логических переменных.

Гарантируется, что все переменные, входящие в выражение, встречаются в списке значений ровно один раз.


Все тесты пройдены, задача сдана:
```hs
module LFCompute where
import LFBasic

compute :: [(String, Bool)] -> LogExpr -> Bool
compute env expr = case expr of
    FConst           -> False
    TConst           -> True
    (Var name)       -> case lookup name env of
                          Just value  -> value
                          Nothing     -> error "Variable not found in environment"
    (Not e)          -> not (compute env e)
    (And e1 e2)      -> compute env e1 && compute env e2
    (Or e1 e2)       -> compute env e1 || compute env e2)
```

Вы можете скачать [тесты для локального запуска](LFCompute.zip).

Для создания значения `LogExpr` по строковому представлению формулы можно использовать функцию `read :: String -> LogExpr` из модуля `LFBasic`. Там же объявлен тип `LogExpr`.
