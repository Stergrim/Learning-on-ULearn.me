# Лесопосадки [review]

Вдоль дороги для защиты её от заметания снегом было высажено `n` берёз. Cо временем деревья болели, гибли, поэтому было проведено какое-то количество замен растений.

Замена полностью описывается тройкой `(l, r, t)` и заключается в том, чтобы убрать старые деревья с `l`-го до `r`-го и посадить на эти места новые деревья типа `t` (берёза имеет тип `1`).

Напишите функцию `plantTrees :: Int -> [(Int,Int,Int)] -> [(Int,Int)]`, которая принимает:
- количество высаженных берёз в первоначальной посадке
- список операций замены деревьев в виде троек `(l,r,t)`

и возвращает количество деревьев каждого имеющегося типа, которые будут расти после выполнения всех операций, виде списка пар `(тип_дерева, количество)`. Список должен быть отсортирован по возрастанию номера типа.

Примеры запуска:

```hs
> plantTrees 10 [(2,5,3),(5,9,2)]
[(1,2),(2,5),(3,3)]
> plantTrees 3 [(1, 3, 100), (3, 3, 2)]
[(2,1),(100,2)]
```

В этой задаче **мы не требуем оптимального решения**. Вы можете считать, что деревьев не больше 500, а изменений не больше 50. Но мы ожидаем, что вы воспользуетесь одной из структур, упомянутых на лекции.

Оригинальная задача на [acm.timus.ru "1147. Цветная бумага"](https://acm.timus.ru/problem.aspx?space=1&num=1147).


Все тесты пройдены, решение ожидает код-ревью:
```hs
module RoadTrees where

import Data.List (group, sort)

plantTrees :: Int -> [(Int, Int, Int)] -> [(Int, Int)]
plantTrees n ops = 
    let initialTrees = replicate n 1
        updatedTrees = foldl applyOp initialTrees ops
        counts = map (\xs -> (head xs, length xs)) . group . sort $ updatedTrees
    in counts
  where
    applyOp trees (l, r, t) = 
        let left = take (l - 1) trees
            middle = replicate (r - l + 1) t
            right = drop r trees
        in left ++ middle ++ right
```
