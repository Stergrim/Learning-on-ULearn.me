# Аналитика из БД

Вася и Коля успешно, перенесли хранение данных в БД, однако, чтобы сделать их решение более универсальным, необходимо основную аналитику осуществлять с помощью SQL-запросов. В этом случае, можно было легко переносить их решение на любой язык программирования, поскольку большинство языков программирования поддерживает SQL, но не все решения используют Pandas.

Когда Вася и Коля обсудили эти моменты, Вася порадовался, что они вместе все-таки правильно реализовывали проект и сейчас в их арсенале есть разные инструменты для решения различных прикладных задач (структурное программирование, функциональное программирование, объектно-ориентированное программирование, различные библиотеки языка Python, среди которых можно специально выделить Pandas, который удобно применять для анализа больших объемов информации, механики тестирования и отладки их приложения, работа с различными структурами данных XML, JSON, работа с API и с базами данных).

По сути, Васе и Коле, нужно было немного переписать решение задач: статистики по городам и статистики по годам, только с тем условием, чтобы запросы были написаны не в формате pandas, а в формате SQL.

Вася написал ТЗ на финальную часть задания:
1. Объединить всю функциональность задач Статистика по городам и Статистика по годам.
2. Использовать в качестве входных данных, данные по вакансиям, которые храняться в БД SQLite, полученные на предыдущем этапе.
3. Выходные данные сохранить в виде датафреймов (в переменные).
4. Для формирования SQL-запросов в БД, можно использовать функцию pd.read_sql (из библиотеки Pandas).
5. Программа должна выводить следующие данные (для каждого вида данных использовать не более 1 SQL-запроса):
   - Динамика уровня зарплат по годам (для решения рекомендуется использовать следующие SQL-операторы: ROUND, AVG, GROUP BY, а также функцию SQLite для работы с датой и временем - strftime). Переменную необходимо назвать `df_years_salary`. Столбцы:
     - `Год` - год публикации
     - `Средняя з/п` - средняя зарплата
   - Динамика количества вакансий по годам. Переменная `df_years_count`. Столбцы:
     - `Год` - год публикации
     - `Количество вакансий` - количество вакансий за этот год
   - Динамика уровня зарплат по годам для выбранной профессии (для решения рекомендуется использовать следующие SQL-операторы: ROUND, AVG, WHERE, LIKE, GROUP BY, а также функцию strftime). Переменная `df_years_salary_vac`. Столбцы:
     - `Год` - год публикации
     - `Средняя з/п - *название вакансии*` - средняя зарплата выбранной вакансии
   - Динамика количества вакансий по годам для выбранной профессии. Переменная `df_years_count_vac`. Столбцы:
     - `Год` - год публикации
     - `Количество вакансий - *название вакансии*` - количество вакансий выбранной вакансии
   - Уровень зарплат по городам (в порядке убывания) - только первые 10 значений (для решения рекомендуется использовать вложенные запросы, SQL-операторы: ROUND, AVG, GROUP BY, HAVING, а также функцию strftime). Переменная `df_area_salary`. Столбцы:
     - `Город` - название города
     - `Уровень зарплат по городам` - среднее значение зарплаты. Округлить до двух символов после запятой.
   - Доля вакансий по городам (в порядке убывания) - только первые 10 значений. Переменная `df_area_count`. Столбцы:
     - `Город` - название города
     - `Доля вакансий` - доля вакансий города среди всех вакансий. Не округлять значение.
На вход подаются название базы данных, название таблицы для анализа и название профессии.

**Формат ввода**

```
example_database
example_table
Разработчик
```

**Формат вывода**

```
df_years_salary = pd.read_sql("SELECT * FROM example")

df_years_count = pd.read_sql("SELECT * FROM example")

df_years_salary_vac = pd.read_sql("SELECT * FROM example")

df_years_count_vac = pd.read_sql("SELECT * FROM example")

df_area_salary = pd.read_sql("SELECT * FROM example")

df_area_count = pd.read_sql("SELECT * FROM example")
```

**Формат таблицы**

| **name**                              | **salary** | **area_name**       | **published_at**              |
|:--------------------------------------|:-----------|:--------------------|:------------------------------|
| **Руководитель группы разработчиков** | **90000**  | **Санкт-Петербург** | **2022-07-17T18:23:06+03:00** |
| **Senior Python Developer (Crypto)**  | **273202** | **Москва**          | **2022-07-05T18:23:15+03:00** |


|                         |               |
|:------------------------|:--------------|
| **Ограничение времени** | **3 секунды** |
| **Ограничение памяти**  | **512.0 Мб**  |


Все тесты пройдены, задача сдана:
```py
import pandas as pd
import sqlite3

database_name = input()
table_name = input()
vac_name = input()

conn = sqlite3.connect(database_name)

df_years_salary = pd.read_sql(f"""
        SELECT strftime('%Y', published_at) as 'Год', ROUND(AVG(salary), 2) as 'Средняя з/п'
        FROM {table_name}
        GROUP BY Год
        """, conn)

df_years_count = pd.read_sql(f"""
        SELECT strftime('%Y', published_at) as 'Год', COUNT(name) as 'Количество вакансий'
        FROM {table_name}
        WHERE salary IS NOT NULL
        GROUP BY Год 
        """, conn)

df_years_salary_vac = pd.read_sql(f"""
        SELECT strftime('%Y', published_at) as 'Год', ROUND(AVG(salary), 2) as 'Средняя з/п - {vac_name}'
        FROM {table_name}
        WHERE name LIKE '{vac_name}%'
        GROUP BY Год
        """, conn)

df_years_count_vac = pd.read_sql(f"""
        SELECT strftime('%Y', published_at) as 'Год', COUNT(name) as 'Количество вакансий - {vac_name}'
        FROM {table_name}
        WHERE name LIKE '{vac_name}%' AND salary IS NOT NULL
        GROUP BY Год
        """, conn)

df_area_salary = pd.read_sql(f"""
        SELECT area_name as 'Город', ROUND(AVG(salary), 2) as 'Уровень зарплат по городам'
        FROM {table_name}
        GROUP BY Город
        HAVING FLOOR(COUNT(*) / (SELECT COUNT(*) * 0.008 FROM {table_name})) >= 1
        ORDER BY AVG(salary) DESC, Город DESC
        LIMIT 10
        """, conn)

df_area_count = pd.read_sql(f"""
        SELECT area_name as 'Город', (COUNT(*) * 1.0 / (SELECT COUNT(*) FROM {table_name})) as 'Доля вакансий'
        FROM {table_name}
        GROUP BY Город
        HAVING FLOOR(COUNT(*) / (SELECT COUNT(*) * 0.008 FROM {table_name})) >= 1
        ORDER BY COUNT(*) / (SELECT COUNT(*) * 0.008 FROM {table_name}) DESC
        LIMIT 10
        """, conn)
```
