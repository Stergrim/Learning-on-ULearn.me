# Единый формат

В поисках работы Вася решил оптимизировать свои старания следующим образом: он нашёл стороннюю библиотеку, которая получает данные с сайта с вакансиями и возвращает в виде специфичного текста. Вася сразу заметил несколько проблем этой библиотеки: в тексте между конструкциями может быть ну очень много лишних пробелов, при этом никакой закономерности в количестве пробелов нет, текст подаётся в виде одной строки, что делает его нечитабельным для пользователя, да и еще значения полей отформатированы как попало!

Наш герой решает исправить эти проблемы алгоритмическим путём!

На вход подаются поля: `Название поля: Значение поля`. Они разделены между собой символом точки с запятой (`;`), который ставится в конце каждой такой конструкции, и пробелами, причем побелов может быть неограниченное количество.

Вам необходимо извлечь каждое поле из строки, которая подаётся, и для необходимых полей обработать каждое значение поля в соответствии с правилами, которые указаны ниже.

Ответ представить в виде словаря, у которого ключ - поле, а значение - обработанное значение поля. Этот словарь закодировать в формат JSON.

**Правила обработки значений полей**

`description`: описание вакансии. Текст вакансии разделен на предложения. Все предложения разделены точкой и одним пробелом (`.`). Необходимо первую букву каждого предложения сделать заглавной, а остальные - строчными.

`salary`: зарплата вакансии. Гарантируется, что в значении поля дано только некое число. Это число необходимо округлить до 2 знаков после точки. Округление не банковское (например `3.333333 -> 3.33`, `5 -> 5.00`, `5.5555 -> 5.56`).

`key_phrase`: главная фраза вакансии, отражающая всю её суть. Сделать все буквы значения заглавными, в конец добавить восклицательный знак (`!`).

`addition`: дополнительная информация о компании. Сделать все буквы значения строчными, в начало и конец добавить две точки (`..`).

`company_info`: информация о компании. Вася решил, что в ней слишком много лишних скобочных конструкций. Убрать из текста все скобочные конструкции (скобки `(` и `)` и то, что между ними).

`key_skills`: ключевые навыки, необходимые для вакансии. На сайте с вакансиями их разделяют не пробелом, а элементом HTML `&nbsp`. При парсинге страницы в Python, текст получается нечитабельным. Замените все подстроки `&nbsp` на пробел.

**Формат ввода**

Первой строкой подаётся строка с полями (конструкции, разделенные точкой с запятой и пробелами).

Второй строкой подаются поля, значение которых необходимо обработать и добавить в ответ. Поля разделены запятой с одним пробелом (`,`). Не гарантируется, что все поля, перечисленные во второй строке, присутствуют в первой строке.

```
description: input. exAMPLE;   salary: 7.3535353535; key_skills: Example&nbspKey&nbspSkills;
description, salary
```

**Формат вывода**

В качестве ответа необходимо вывести на экран словарь формата ключ - поле, значение - обработанное значение поля. Словарь должен быть закодирован в формат JSON.

```
{"description": "Input. Example", "salary": "7.35"}
```

|                         |                       |
|:------------------------|:----------------------|
| **Ограничение времени** | **1 секунда**         |
| **Ограничение памяти**  | **64.0 Мб**           |


Все тесты пройдены, задача сдана:
```py
import json
import re

text = input()
headings = input()

pairs_pattern = re.compile(r'\s*([^:;]+?)\s*:\s*([^;]*?);')
raw_fields = {k.strip().lower(): v for k, v in pairs_pattern.findall(text)}

needed = [h.strip().lower() for h in headings.split(',') if h.strip()]

def normalize_description(value: str) -> str:
    parts = value.split('. ')
    out = []
    for s in parts:
        s = s.strip()
        if not s:
            continue
        out.append(s[0].upper() + s[1:].lower() if len(s) > 1 else s.upper())
    return '. '.join(out)

def normalize_salary(value: str) -> str:
    return f"{float(value):.2f}"

def normalize_key_phrase(value: str) -> str:
    return value.upper() + '!'

def normalize_addition(value: str) -> str:
    return f"..{value.lower()}.."

def normalize_company_info(value: str) -> str:
    cleaned = value
    paren_pattern = re.compile(r'\([^()]*\)')
    while paren_pattern.search(cleaned):
        cleaned = paren_pattern.sub('', cleaned)
    return cleaned

def normalize_key_skills(value: str) -> str:
    return value.replace('&nbsp', ' ')

handlers = {
    'description': normalize_description,
    'salary': normalize_salary,
    'key_phrase': normalize_key_phrase,
    'addition': normalize_addition,
    'company_info': normalize_company_info,
    'key_skills': normalize_key_skills,
}

result = {}
for field in needed:
    if field in raw_fields:
        handler = handlers.get(field, lambda x: x)
        result[field] = handler(raw_fields[field])

print(json.dumps(result, ensure_ascii=False))
```
