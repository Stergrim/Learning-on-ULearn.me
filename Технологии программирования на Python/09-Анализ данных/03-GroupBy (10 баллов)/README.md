# GroupBy

И даже на этом Вася не остановился. Теперь ему стало интересно, в каких городах самые высокие зарплаты! Работая с той же [vacancies_small.csv](vacancies_small.zip), нужно получить словарь, в котором в порядке убывания будут отображены города и соответствующие им *средние* зарплаты. Если значения ключей совпадают, то нужно расположить элементы в алфавитном порядке.

Рассматриваются только те вакансии, у которых валюта зарплаты указана в российских рублях (RUR). Вакансии с другой валютой не рассматриваются. Зарплату округлить до целого.

**Формат вывода**

```
{'Москва': 143810, 'Волгодонск': 130000, 'Екатеринбург': 122500, 'Санкт-Петербург': 109464, 'Домодедово': 105000, ...
```

В качестве зарплаты подразумевается среднее арифметическое значение столбцов salary_to, salary_from. Если значение в одном из столбцов отсутствует, то брать только оставшийся столбец.

|                         |               |
|:------------------------|:--------------|
| **Ограничение времени** | **3 секунды** |
| **Ограничение памяти**  | **512.0 Мб**  |


Все тесты пройдены, задача сдана:
```py
import pandas as pd

vacancies = pd.read_csv('vacancies_small.csv')

df = vacancies[['area_name', 'salary_from', 'salary_to', 'salary_currency']]
df = df.loc[df['salary_currency'] == 'RUR']
df['average_salary'] = df[['salary_from','salary_to']].mean(1, skipna=True)
df = df.drop(['salary_from', 'salary_to', 'salary_currency'], axis=1)

dictionary = (df
              .groupby('area_name')['average_salary']
              .agg('mean')
              .round()
              .astype(int)
              .to_dict()
)

print(dict(sorted(dictionary.items(), key=lambda x: x[1], reverse=True)))
```
