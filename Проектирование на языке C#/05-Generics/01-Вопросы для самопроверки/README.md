# Вопросы для самопроверки

1. Чем полезны Generic-типы?

**Ответ:**

С их помощью можно писать код, который работает со множеством разных типов. Они позволяют создавать гибкие и переиспользуемые компоненты без дублирования кода и без жертв безопасности типов.

2. Вспомните примеры Generic-типов

**Ответ:**

Коллекции и Linq.

3. Какую проблему решают Generic-типы?

**Ответ:**

Проблему небезопасности приведения типов (даункастов).

4. Как объявить Generic-класс?

**Ответ:**

С помощью угловых скобок:

```cs
public class MyList<T>{ ... }
```

5. Как предъявлять требования к типам-параметрам Generic-типа?

**Ответ:**

С помощью ключевого слова `where`:

```cs
public class SortedList<T> where T : IComparable
```

6. Что такое Generic-метод?

**Ответ:**

Это методы, которые могут быть объявлены в том числе не в Generic-типах, но при этом имеют свои Generic-параметры для аргументов или возвращаемого значения метода.

7. Как объявлять Generic-метод?

**Ответ:**

```cs
T FindMax<T>(IEnumerable<T> en) 
{
    ...
}
```

8. Что такое **default(T)**?

**Ответ:**

Это значение по умолчанию переменной типа T. 0, false, ... для примитивных типов; пустая структура; null для классов.

9. Нужно ли явно указывать тип Generic-аргумента для Generic-метода?

**Ответ:**

Чаще всего нет, так как компилятор способен самостоятельно вывести тип дженерик-параметра метода из типов его аргументов.

```cs
var t_short = Tuple.Create(1, "string");
var t_full = Tuple.Create<int, string>(1, "string");
```

10. Что такое **Extensions Generic методы**?

**Ответ:**

Методы, которые добавляются в другой класс или интерфейс.

```cs
T FindMax<T>(this IEnumerable<T> en)
    where T : IComparable
    {
        ...
    }
```

11. Что такое Ковариантность?

**Ответ:**

Ситуация, когда иерархию наследования параметров типов generic-интерфейса можно перенести на сам дженерик интерфейс:

```cs
IEnumerable<string> strings = ...;
IEnumerable<object> objects = strings;
```

12. Что такое Контрвариантность?

**Ответ:**

Ситуация, когда иерархию наследования параметров типов generic-интерфейса можно перенести на сам дженерик интерфейс, но в обратном порядке:

```cs
Action<object> handleObject = ...;
Action<string> handleString = handleObject;
```
