# Фильтрации по нескольким колонкам

**Общий принцип**

При фильтрации по нескольким колонкам в общем случае создай общий индекс на все колонки.

Например, для запроса `SELECT * FROM table WHERE f1='a' AND f2='b' AND f3='c';`

Нужно создать индекс `CREATE INDEX ON table (f1, f2, f3);`

[Смотри документацию по составным индексам](https://postgrespro.ru/docs/postgresql/13/indexes-multicolumn).

**Порядок колонок в общем индексе**

Колонки в индексе стоит располагать в порядке уменьшения селективности. Т.е. первой колонкой должна быть колонка, по которой фильтр сильней уменьшит выборку. Порядок колонок в запросе не влияет на порядок колонок в индексе. Тип колонок обычно тоже не влияет на порядок – гораздо важней селективность колонок.

**Применимость индекса из нескольких колонок**

Если создан индекс на несколько колонок, например, Index (F1, F2, F3), то он может использоваться для фильтрации по колонкам F1 + F2 + F3, F1 + F2, F1. Индекс НЕ будет использоваться при фильтрации по другим сочетаниям колонок. Таким образом при создании индекса нужно руководствоваться и тем, какие выборки нужно будет строить по данным.

Индекс на несколько колонок работает только для запросов, где условия на колонки соединяются условием AND. Индекс не будет работать для запросов с условием OR между ограничениями на колонки из индекса.

Составные индексы следует использовать обдуманно. В большинстве случаев индекс по одному столбцу будет работать достаточно хорошо и сэкономит время и место. Индексы по более чем трём столбцам вряд ли будут полезными, если только таблица не используется крайне однообразно.

**Индексы на отдельные колонки**

В запросах с фильтрацией по нескольким колонкам БД может задействовать несколько индексов на отдельные колонки, применяя битовые карты. Т.е. иногда целесообразно сделать несколько отдельных индексов на отдельные колонки и проверить план. Такие индексы более универсальные, но будут работать медленней, чем общий индекс на несколько колонок.

Например, для запроса `SELECT * FROM table WHERE f1 = 'a' AND f2= 'b';`

В некоторых случаях достаточно будет двух индексов `CREATE INDEX ON table (f1);` и `CREATE INDEX ON table (f2);`.

[Подробнее смотри в документации](https://postgrespro.ru/docs/postgresql/13/indexes-bitmap-scans).


**Задание**

Выполняй запросы в PGAdmin на демо-базе.
1. Удали все индексы на таблице с рейсами (flights).
2. Выбери все запланированные рейсы `status='Scheduled'` из Домодедово `departure_airport='DME'` в Новосибирск `arrival_airport='NSK'`.
3. Посмотри план запроса, тип доступа к данным, оценку.
4. Какие индексы будет быстрей всего работать? Как ответить на этот вопрос, не строя индексы?
5. Последовательно создавай индексы на указанные колонки и построй план запроса. В каждом плане проверь итоговую оценку и тип доступа к данным.
   - status
   - departure_airport
   - arrival_airport
   - departure_airport + arrival_airport
   - arrival_airport + departure_airport
   - departure_airport + arrival_airport + status
   - arrival_airport + departure_airport + status
6. В какой момент БД решила одновременно использовать несколько индексов? Какие индексы?
7. Какие индексы в итоге БД использует для выполнения запроса? Т.е. какое сочетание индексов в итоге оптимальное?
8. В ответе напишите SQL создания индексов, которые использует БД для выполнения запросов.

**Все тесты пройдены, задача сдана:**
```pgsql
Create Index flights_arrival_departure_status_idx On flights(arrival_airport, departure_airport, status);
```
