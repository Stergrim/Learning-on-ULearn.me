# Изменение внешних ключей

Редактор не смог удалить рубрику, так как с ней были связаны статьи. И попросил настроить автоматическое удаление связей, при удалении рубрики.

**Задание**
1. [Посмотри синтаксис команды ALTER TABLE](https://postgrespro.ru/docs/postgresql/13/sql-altertable)
2. Поменяй ограничение `articles_article_rubric_id_fkey`, созданное в прошлом задании. Сделай так, чтобы при удалении рубрики из справочника - связанные статьи оставались в таблице, а связи удалялись. Действия при обновлении связанных записей не должны измениться - при изменении ID рубрики, связанные статьи должны автоматически менять связь.
3. Удали вторую рубрику. Посмотри, что произошло со статьями, связанными с ней.
4. Измени ID первой рубрики на 2. Что произошло со статьями, которые ранее были связаны с первой рубрикой?
5. Получи все статьи и их рубрики, даже если рубрика не задана.<br> **Формат вывода:** ID статьи | ID рубрики | Название рубрики

**Примечание**

Рекомендуется при создании внешнего ключа всегда в явном виде настраивать подходящее поведение при удалении связанных записей.

Настройка поведения при обновлнеии связанных записей менее критична, т.к. первичные ключи редко меняются, а значит подойдёт ограничение по умолчанию, которое будет запрещать такие действия.

**Контрольные вопросы**
- Как изменить настройки у внешнего ключа?
- Какое поведение внешнего ключа можно указать, при обновлении ID в главной таблице (на которую ссылаемся)?
- Если в синтаксисе `REFERENCE таблица` не указываем колонку на какую ссылаемся, то на какую колонку получится ссылка?

**Все тесты пройдены, задача сдана:**
```pgsql
-- Удаляем старое ограничение внешнего ключа
Alter Table articles 
Drop Constraint articles_article_rubric_id_fkey;

-- Создаем новое ограничение
Alter Table articles 
Add Constraint fk_articles_rubrics 
Foreign Key (article_rubric_id) 
References article_rubrics(article_rubric_id)
On Update Cascade
ON Delete Set Null;

-- Удаляем рубрику 'Вебинары' (ID=2)
Delete From article_rubrics 
Where article_rubric_id = 2;

-- Изменяем ID первой рубрики с 1 на 2
Update article_rubrics 
Set article_rubric_id = 2 
Where article_rubric_id = 1;

-- Получаем все статьи и их рубрики (даже если рубрика не задана)
Select 
    article_id as "ID статьи",
    article_rubric_id as "ID рубрики",
    ar.title as "Название рубрики"
From articles
Left Join article_rubrics ar Using(article_rubric_id)
Order by article_id;
```
