# Связь многие-ко-многим

Редактор журнала не смог привязать статью сразу к двум рубрикам и попросил исправить ситуацию.

Для хранения нескольких связей между двумя сущностями обычно используется отдельная таблица связи, которая содержит колонки-ссылки на первичные ключи связываемых таблиц. Такие связи называются “многие-ко-многим”.

**Задание**
1. Добавь таблицу для хранение связей `article_rubric_links`.
2. При удалении Статей или Рубрик связи должны автоматически удаляться.
3. Первичным ключом сделай отдельное автоинкрементное поле. Используй стандарт именования, который описан в начале урока.
4. Настрой проверку уникальности связей.
5. Удали старую связь, не потеряв данные.
6. Покажи, что таблица заполнена правильно — получите все записи из новой таблицы.

**Примечание про каскадное удаление**

Обычно в таблицах для хранения связей многие-ко-многим нет колонок, кроме колонок-ссылок на другие таблицы. В таких случаях чаще всего настраивается каскадное удаление связей, при удалении строк из главных таблиц. Почему?

**Примечание про первичный ключ**

Первичным ключом в такой таблице может быть
- Вариант 1: либо набор всех колонок-ссылок, например `PRIMARY KEY (table1_id, table2_id)`
- Вариант 2: либо отдельное поле, например `COLUMN table_links_id INT SERIAL`

**Примечание про уникальность связи**

Чаще всего связь должна быть уникальная. Уникальность можно обеспечить, создавая первичный ключ с набором всех колонок-ссылок (см. выше Вариант 1). Либо создавая отдельный уникальный индекс на эти колонки - UX(table1_id, table2_id).

**Примечание про скорость работы**

Для ускорения проверки ограничений на внешние ключи и для получения связанных данных обычно сразу создаются составные индексы с колонками-связями (ID1, ID2) и (ID2, ID1), если ещё нет такого первичного ключа и уникального индекса. Про оптимизацию будет рассказано подробнее в следующих уроках.

**Примечание про сложность связей многие-ко-многим**

При разработке приложений старайтесь минимизировать количество связей многие-ко-многим, т.к. их гораздо сложней поддерживать, чем связи один-ко-многим.

**Контрольные вопросы**
- Какой может быть первичный ключ в таблицах многие-ко-многим?
- Как обеспечить уникальность связей?
- Какой типичный тип поведения внешнего ключа при `ON DELETE`?

**Все тесты пройдены, задача сдана:**
```pgsql
-- Создаем таблицу связей
Create Table article_rubric_links (
    article_rubric_link_id Serial Primary Key,
    article_id Integer Not Null References articles(article_id) On Delete Cascade,
    article_rubric_id Integer Not Null References article_rubrics(article_rubric_id) On Delete Cascade,
    Unique (article_id, article_rubric_id)
);

-- Переносим существующие
Insert Into article_rubric_links (article_id, article_rubric_id)
Select article_id, article_rubric_id 
From articles 
Where article_rubric_id Is Not Null;

-- Удаляем старую колонку связи
Alter Table articles Drop Column article_rubric_id;

-- Проверяем результат
Select 
    article_rubric_link_id,
    article_id, 
    article_rubric_id
From article_rubric_links 
Order by article_rubric_link_id;
```
