# Вопросы для самопроверки

1. Зачем нужны графы?

**Ответ:**

Это абстракция, подходящая для моделирования огромного количества задач из реального мира:

Социальные сети, карты и планы, отношения между объектами, зависимости между библиотеками, диаграмы переходов машин из одного состояния в другое и многое другое.

2. В чем заключается принцип обхода лабиринта в глубину?

**Ответ:**

Мы идем в каком-то одном направлении пока можем. Как только путь заканчивается, и мы не можем никуда пойти, мы откатываемся до предыдущей развилки и идем уже в другом направлении.

3. Каков недостаток обхода лабиринта в глубину через рекурсию?

**Ответ:**

Главный недостаток такого метода — это память. Если делать обход лабиринта большого размера, к примеру 1000х1000, то в стеке будет тысяча рекурсивных вызовов метода, что вызовет переполнение стека, и программа выдаст исключение. Поэтому при обходе в глубину не рекомендуется использовать рекурсию.

4. Как решить проблему с памятью при обходе лабиринта в глубину через рекурсию?

**Ответ:**

Использовать свой собственный стек.

5. Подходит ли поиск в глубину для поиска кратчайшего пути в графе?

**Ответ:**

Нет. Поиск в глубину в классической реализации найдет произвольный путь.

Несложно модифицировать его так, чтобы он перебрал все пути в графе, сделав его экспоненциальным переборным алгоритмом.

6. В чем заключается принцип обхода лабиринта ширину?

**Ответ:**

Отличительной особенностью обхода лабиринта в ширину является использование очереди, куда помещаются еще не посещенные точки. Поэтому получается волнообразный поиск, когда мы идем по одному шагу во всех направлениях сразу.

7. Какой принцип работы алгоритма Кана для топологической сортировки?

**Ответ:**

На каждом шаге находим вершину графа, в которую не заходит ни одно ребро и удаляем её, вместе со всеми инцедентными ребрами. Повторяем, пока можем. Последовательность удаленных вершин — результат сортировки.

Если в конце алгоритма остались не удаленные вершины, то топологическая сортировка невозможна.

8. Какой принцип работы алгоритма Тарьяна для топологической сортировки?

**Ответ:**

Запускаем обход графа в глубину. На каждом возврате по ребру, заносим в список вершину, из которой возвращались.

Переворачиваем получившийся список — это результат топологической сортировки.
