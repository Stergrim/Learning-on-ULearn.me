# Практика «Diff Tool»

Продолжайте [в том же проекте](Antiplagiarism.zip).

Алгоритм из предыдущей задачи находит похожие пары документов. В этой задаче вам предстоит проанализировать два документа и найти в них повторяющиеся части. Подобную задачу решают так называемые Diff Tools — инструменты для сравнения текстовых файлов.

Для этого вам нужен алгоритм, который будет по двум последовательностям токенов возвращать их наибольшую общую подпоследовательность. Она должна состоять из токенов первой последовательности, которые в том же порядке присутствуют и во второй последовательности (токены не обязательно должны идти подряд). И из всех таких последовательностей вернуть нужно самую длинную. Если самых длинных несколько, можно вернуть любую.

Например, у документов `a1 b2 ab1 b21 b2` и `b2 b2 a1` (токены разделены пробелом) наибольшая общая подпоследовательность — это `b2 b2` и имеет длину 2 токена.

Реализуйте это в методе `Calculate` в классе `LongestCommonSubsequenceCalculator` и отладьте реализацию на тестах `LongestCommonSubsequenceCalculator_Tests`. Как и в прошлой задаче документы приходят в ваш метод уже разбитые на токены, вам этого делать не нужно.

**Подсказки по алгоритму**

Поиск длины наибольшей общей подпоследовательности — ещё одна классическая задача динамического программирования. Она решается, как и расстояние Левенштейна, с помощью построчного заполнения двумерного массива, назовём его `opt`, с таким инвариантом:

`opt[i1, i2]` — это длина наибольшей общей подпоследовательности префикса первого документа длины `i1` и префикса второго документа длины `i2`.

В частности `opt[0, 0] = 0` (оба префикса пустые). А `opt[first.Length, second.Length]` — это длина искомой подпоследовательности для документов `first` и `second`. Начните с того, что напишите формулу для расчёта значения очередной ячейки `opt[i1, i2]` через уже известные ячейки `opt`.

Саму подпоследовательность можно найти по заполненной матрице, начав с `opt[first.Length, second.Length]`.

**Запуск проекта**

В папке `SuspiciousSources` лежат документы, которые нужно проверить на плагиат. После того, как вы отладите ваше решение на тестах, запустите проект на исполнение. На консоль выведется расстояние Левенштейна между каждой парой документов, а в директории с exe-файлом появится html-файл с отчётом, где у двух решений будет выделена общая часть. Откройте этот отчёт в браузере и изучите результат!

**Обсуждение скорости работы алгоритмов**

Оба алгоритма из этой серии задач имеют квадратичную сложность относительно размера документа. Кроме того, для сравнение каждого документа с каждым — тоже квадратичная операция относительно количества документов. Из-за этого, как вы могли заметить, поиск похожих пар документов работает не особенно быстро. А значит для анализа тысяч решений, размером в килобайт, нужно искать другой более быстрый алгоритм.

Все тесты пройдены, задача сдана:
```cs
using System;
using System.Collections.Generic;

namespace Antiplagiarism;

public static class LongestCommonSubsequenceCalculator
{
    public static List<string> Calculate(List<string> first, List<string> second)
    {
        var opt = CreateOptimizationTable(first, second);
    
        for (int i = 1; i <= first.Count; ++i)
            for (int j = 1; j <= second.Count; ++j)
                if (first[i-1].Equals(second[j-1]))
                    opt[i,j] = opt[i-1,j-1] + 1;
                else
                    opt[i, j] = Math.Max(opt[i - 1, j], opt[i, j - 1]);
    
        return RestoreAnswer(opt, first, second);
    }
    
    private static int[,] CreateOptimizationTable(List<string> first, List<string> second)
    {
        var optTable = new int[first.Count + 1, second.Count + 1];
        return optTable;
    }
    
    private static List<string> RestoreAnswer(int[,] opt, List<string> first, List<string> second)
    {
        var listLCS = new List<string>();
        int i = first.Count;
        int j = second.Count;
    
        while (opt[i,j] > 0)
            if (first[i - 1].Equals(second[j - 1]))
            {
                listLCS.Add(first[i - 1]);
                i--;
                j--;
            }
            else
                if (opt[i - 1, j] > opt[i, j - 1]) i--;
                else j--;
    
        listLCS.Reverse();
        return listLCS;
    }
}
```

**Проект со всеми внесенными решениями.**
[Antiplagiarism Edit](Antiplagiarism_Edit.zip)
