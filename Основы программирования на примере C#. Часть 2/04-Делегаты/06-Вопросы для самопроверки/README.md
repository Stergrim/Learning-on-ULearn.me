# Вопросы для самопроверки

1. Какое ключевое слово используется при определении делегата? И как выглядит определение делегата?

**Ответ:**

Используется ключевое слово: `delegate`.

Пример:

```cs
public delegate int CalculatePlus(int num1, int num2);
```

2. Предположим у нас есть делегат
```cs
Func<int, int> func = x => x + 5;
```
Какими двумя способами мы можем его вызвать?

**Ответ:**

Первый способ: `func(5);`<br>
Второй способ: `func.Invoke(5);`

Это два абсолютно одинаковых вызова, но предпочтительнее использовать первый.

3. Предположим метод `Sort` принимает делегат, который он будет использовать для сравнения, и мы хотим передать в него свой сравниватель `MyComparer`. Как будет выглядеть сокращенная запись передачи делегата?

**Ответ:**

Он будет выглядеть следующим образом: `array.Sort(MyComparer);`<br>
Двойные скобки при передаче делегата не указываются.

4. Возможно ли объявить делегат не явным образом?

Пример:
```cs
var comparer = (x, y) => x >= y;
```

**Ответ:**

Нет, такая запись приведет к ошибке компиляции. Компилятор не сможет понять, каким типом является «x» и «y», поэтому ему необходимо явно указать о каких типах идет речь.

Правильная запись:

```cs
Func<int, int, bool> comparer = (x, y) => x >= y;
```

5. Какие поля хранит объект делегатного типа, и где он хранится в памяти?

**Ответ:**

Объект делегатного типа состоит из пары полей: `target` и `method`, и хранится он в куче.

6. Какую функцию выполняют поля `target` и `method` у объекта делегатного типа?

**Ответ:**

Поле `method` указывает на сам метод в памяти, а `target` указывает на объект из которого нужно вызвать этот метод, если он динамический. Если метод статический, то `target` равен `null`.

7. Назовите два типа встроенных в .NET делегатов? Чем они отличаются друг от друга?

**Ответ:**

В .NET есть два типа встроенных делегатов: `Func` и `Action`.

`Func` - имеет возвращаемый тип.<br>
Например, `Func<int, int, bool>` принимает два числа типа `int` и возвращает `bool`.

`Action` - не имеет возвращаемого типа.<br>
Например, `Action` - не имеет возвращаемого типа и принимаемых аргументов.<br>
`Action<int>` - не имеет возвращаемого типа и принимает в качестве аргумента переменную типа `int`.

8. Предположим мы хотим вызвать метод `Sort`, который принимает массив и делегат `Comparer`, и передать ему наш сравниватель, например `MyComparer`. Как будет выглядеть запись вызова при помощи анонимного делегата?

**Ответ:**

```cs
Sort(someArray, delegate(int x, int y) { return x > y; });
```

9. Как выглядит запись лямбда-выражения, которое принимает число «x» и выводит его на консоль?

**Ответ:**
```cs
Action<int> print = (x) => Console.WriteLine(x).
```
На самом деле здесь есть одна хитрость, можно написать просто:
```cs
Action<int> print = Console.WriteLine
```
без «x» в скобках, и такое лямбда-выражение все равно выведет на консоль «x». Это работает, потому что компилятор сам в состоянии догадаться, что принимаемый аргумент надо поместить в вызываемую функцию. Однако такой способ не работает с несколькими переменными:
```cs
(x, y) => Console.WriteLine
```
не сработает по причине неоднозначности выражения.

10. Что такое замыкание?

**Ответ:**

Замыкание - это ситуация, когда в лямбда-выражении используется переменная из другого метода.

11. Что такое ловушка замыкания?

**Ответ:**

Ловушка замыкания - это ситуация, когда в лямбда-выражении используется общая переменная для всех итераций в цикле. Частый пример ловушки замыкания это, когда используется в лямбда-выражении переменная `i` принадлежащая циклу `for`. Такая переменная становится по итогу полем класса, и соответственно становится общей для всех итераций в цикле.

12. Что принимает и возвращает делегат такого типа: `Func<int> someFunction?`

**Ответ:**

`someFunction` не имеет принимаемых аргументов и возвращает переменную типа `int`.

13. У всех методов есть своё имя, но существует ли оно у анонимного делегата?

**Ответ:**

Существует. Его автоматически генерирует компилятор на этапе компиляции, и имя можно легко увидеть во время отладки программы.
