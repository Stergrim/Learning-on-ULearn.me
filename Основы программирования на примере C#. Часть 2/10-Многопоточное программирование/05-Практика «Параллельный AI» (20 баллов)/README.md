# Практика «Оптимальный маршрут»

Продолжайте [в том же проекте](rocket-bot.zip).

В этой задаче вам нужно распараллелить искусственный интеллект в несколько потоков. Изучите класс `Bot`. Метод `SearchBestMove` ищет оптимальный следующий ход для ракеты: повернуть влево, вправо или продолжить лететь прямо. Он делает это, перебирая заданное количество случайных последовательностей ходов, и выбирает первый ход той последовательности, которая дала наилучший результат, т.е. собрано больше всего флажков и вы находитесь ближе всего к следующему флажку. Понятно, что чем больше бот успеет перебрать случайных последовательностей ходов, тем больше у него будет шансов найти решение лучше. Однако, вместе с качеством увеличится и время вычисления очередного хода.

Для того, чтобы повысить производительность, можно распараллелить поиск очередного хода. Например, в два потока можно искать ход следующим образом: половину последовательностей перебирать в одном потоке, половину — в другом, а затем из двух полученных последовательностей ходов выбрать лучшую. Тогда время на вычисление очередного хода у вас сократится в два раза.

Если посмотреть на конструктор класса `Bot`, можно заметить, что в нём никак не используется параметр `threadsCount` — количество потоков, в которое будет вычисляться очередной ход. Перепишите метод `GetNextMove` (он находится в отдельном файле `Bot_Parallel.cs`) так, чтобы он искал следующий ход в указанное количество потоков. Обратите внимание, что класс `Random` не является потокобезопасным. То есть, у каждого потока должен быть свой объект этого класса.

В этом задании вам нужно переписать только метод `GetNextMove`, другие методы менять не нужно. Для удобства проверки этот метод вынесен в отдельный файл `Bot_Parallel.cs` (Подробнее о том, как можно разделять описание одного класса по нескольким файлам, читайте в [документации по ключевому слову partial](https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods). Стоит добавить, что в реальных проектах не стоит использовать partial classes, если есть другие способы декомпозиции вашего кода на части.)

**Тестирование**

Протестируйте ваш метод на тестах `BotTests`. В каждом тесте описана ситуация, в которой следующий ход достаточно очевиден. Ваш искусственный интеллект должен верно определять этот ход хотя бы в 90% случаев. Также, для каждого теста проверяется, что на нём ваш искусственный интеллект в два потока работает быстрее, чем в один хотя бы в 90% запусков.

Кроме того, при запуске приложения на выполнение, вы можете заметить, что просчёт ходов после вашей доработки начал происходить быстрее (зеленая полоска начала двигаться быстрее).

Все тесты пройдены, задача сдана:
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace rocket_bot;

public partial class Bot
{
    public Rocket GetNextMove(Rocket rocket)
    {
        var listTask = CreateTasks(rocket)
            .Select(task => SearchBestMove(rocket, new Random(), iterationsCount / threadsCount))
            .AsParallel()
            .ToList();
    
        var bestTask = listTask.Where(task => task.Score == listTask.Max(x => x.Score)).First();
        return rocket.Move(bestTask.Turn, level);
    }
    
    public List<Task<(Turn Turn, double Score)>> CreateTasks(Rocket rocket)
    {
        return new() { Task.Run(() => SearchBestMove(rocket, new Random(random.Next()), iterationsCount)) };
    }
}
```

**Проект со всеми внесенными решениями.**
[rocket-bot Edit](rocket-bot_Edit.zip)
