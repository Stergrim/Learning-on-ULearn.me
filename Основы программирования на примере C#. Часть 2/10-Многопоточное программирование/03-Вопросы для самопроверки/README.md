# Вопросы для самопроверки

1. Что такое поток в многопоточном программировании?

**Ответ:**

Поток - это последовательность выполняющихся инструкций.

2. Как запустить некую функцию `MakeWork` в другом потоке используя класс `Thread`?

**Ответ:**

Создать объект класса `Thread` и вызвать метод `Start`.

Пример:
```cs
var thread = new Thread(() => MakeWork());
thread.Start();
```

3. Можно ли потоку задать приоритет используя класс `Thread`?

**Ответ:**

Да, можно, через свойство `Priority`.

Пример:
```cs
var thread = new Thread(() => MakeWork());
thread.Priority = ThreadPriority.Lowest;
thread.Start();
```

4. Как запустить некую функцию `MakeWork(3)` в другом потоке используя метод `BeginInvoke` и после выполнения получить результат?

**Ответ:**

Создать делегат, который будет вызывать `MakeWork`, вызвать метод `BeginInvoke` и затем получить результат используя метод `EndInvoke`.

Пример:
```cs
var func = new Func<int, double>(MakeWork);
```

5. Что происходит с тредом, когда он доходит до строчки с командой `EndInvoke`?

**Ответ:**

Тред ждет, пока другой поток не закончит свою работу и не вернет результат.

6. Как запустить некую функцию `MakeWork(int id)` в нескольких потоках используя класс `Parallel`, так чтобы `id` у всех был разный?

**Ответ:**

Использовать метод `For`.

Пример:
```cs
Parallel.For(0, 10, MakeWork);
```

7. Что делает команда `lock`?

**Ответ:**

Команда `lock` помогает заблокировать доступ к непотокобезопасным объектам так, чтобы другие потоки с `lock` не могли к ним обратиться до тех пор, пока другой `lock` не откроет доступ.

8. Можно ли производить какие-то операции с контролами WindowsForms из другого потока? К примеру, выполнить операцию:

```cs
label.Text = "Все готово!"
```

**Ответ:**

Нет, нельзя. Все обращения и работа с контролами должна производиться в главном потоке приложения.

9. Как из другого потока вызвать обновление контрола в главном потоке приложения?

**Ответ:**

Использовать обычный метод `BeginInvoke` принадлежащий классу `Form`. Не путать с `BeginInvoke` делегата - это разные методы.

10. Как запустить некую функцию `MakeWork`, возвращающую `string`, в другом потоке, используя класс `Task`? Как получить из него результат?

**Ответ:**

Создать `Task` объект и вызвать функцию `Start`. Чтобы получить результат необходимо обратиться к свойству `Result`.

Пример:
```cs
var task = new Task<string>(() =>
    { Thread.Sleep(5000); return "Completed"; });
task.Start();
task.Wait();
return task.Result;
```

11. Каким ключевым словом должен быть помечен метод, чтобы можно было использовать команду `await` в теле метода?

**Ответ:**

Ключевым словом: `async`. Если его не указать, то использование `await` приведет к ошибке компиляции.

12. Что должен возвращать метод, чтобы к нему можно было применить оператор `await`?

**Ответ:**

Метод должен возвращать объект типа `Task`. Причем `await` cам вместо нас обратится к свойству `Result` и вернет это значение.

13. В каком потоке и когда выполняется код, после того как `await` вернул результат?

**Ответ:**

Код выполняется в родительском потоке, то есть из того потока, который в первый раз зашел в этот метод.

14. Как запустить некую функцию `MakeWork` в другом потоке используя класс `BackgroundWorker`?

**Ответ:**

Подписать `MakeWork` на событие `DoWork` и вызвать метод `RunWorkerAsync`.

15. Как с помощью `BackgroundWorker-а` по завершению выполнения какого-то метода обратиться к контролу `WindowsForm`?

**Ответ:**

Можно просто подписать метод или лямбда-выражение на событие `RunWorkerCompleted`, и `BackgroundWorker` сам разберется, что и в каком треде запускать, поэтому никаких ошибок не произойдет.
