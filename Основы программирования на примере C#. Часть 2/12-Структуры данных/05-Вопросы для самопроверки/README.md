# Вопросы для самопроверки

1. Какой отличительной особенностью обладает бинарная куча?

**Ответ:**

У бинарной кучи минимальный элемент всегда находится в корне.

2. Каким образом формируются индексы у бинарной кучи при её реализации в виде массива?

**Ответ:**

Корень кучи имеет индекс 1, а её узлы имеют индексы `2 * i` и `2 * i + 1`, где `i` индекс родительского узла.

3. Зачем нужен метод `HeapifyUp` в классе бинарной кучи? По какому принципу он работает?

**Ответ:**

`HeapifyUp` нужен, чтобы восстановить свойство бинарной кучи, когда каждый элементы кучи должен быть меньше своего родителя.

Принцип работы: производит сравнение текущего элемента и его родителя, если текущий элемент меньше, меняет их местами и повторяет операцию, иначе прерывает цикл.

4. Что мы должны сделать после удаления корня в бинарной куче?

**Ответ:**

Повесить самый правый элементы кучи на последнем этаже в корень и вызвать метод `HeapifyDown`.

5. Зачем нужен метод `HeapifyDown` в классе бинарной кучи? По какому принципу он работает?

**Ответ:**

Используется для протаскивания элемента вниз по бинарной куче, чтобы восстановить её свойство.

Принцип работы схож с методом `HeapifyUp`: производит сравнение текущего элемента и его потомков, если текущий элемент больше, меняет их местами и повторяет операцию, иначе прерывает цикл.

6. Какими отличительным особенностями обладает левонаправленное бинарное дерево?

**Ответ:**

1. У каждого узла может быть не более двух потомков.
2. Все левые элементы бинарного дерева должны быть строго меньше `<`.
3. Правые элементы бинарного дерева должны быть не меньше `>=` корня.

Если дерево правонаправленное, то пункты 2 и 3 становятся противоположными. Т.е. элементы правого поддерева строго меньше `<`, а левые не меньше `>=` родительского узла.

7. Каковы трудозатраты у методов добавления и поиска в бинарном дереве?

**Ответ:**

Добавление нового элемента зависит от высоты дерева и примерно занимает ***O(log n)***, где ***n*** — общее количество элементов. Поиск элемента занимает ***O(h)***, где ***h*** — высота дерева.

8. Как перечислить элементы левонаправленного бинарного дерева в порядке возрастания?

**Ответ:**

Вначале взять самый левый элемент, затем взять родительский узел, потом взять правый элемент этого узла. Повторить операцию. Подняться на узел выше. Повторить все заново.

9. При удалении узла с двумя поддеревьями в левонаправленном бинарном дереве на какой элемент мы должны его заменить?

**Ответ:**

На самый левый элемент правого поддерева.

10. Подумайте какая реализация бинарного дерева лучше в виде связного списка или массива? В чем минусы и плюсы реализаций?

**Ответ:**

Основное преимущество массива над связным списком является скорость. Используя массив достаточно легко и быстро, можно получить доступ к максимальному и минимальному значению: мы просто считаем индексы в зависимости от количества элементов в дереве. Большим недостатком массива и большим преимуществом бинарного списка является занимаемый объем памяти. Если бинарное дерево окажется неравномерным, массив может привести к переполнению всей памяти, в то время как список будет занимать столько места сколько необходимо для хранения всех элементов.

Пример: если мы будем добавлять 1000 элементов по убыванию в бинарное дерево реализованное с помощью массива, это приведет к тому, что нам придется постоянно увеличивать объем массива, пока мы не перейдем лимит в 2 ГБ и программа не выведет нам исключение. Тогда как при использовании связного списка такого не возникнет, и памяти будет занято ровно столько сколько необходимо.
